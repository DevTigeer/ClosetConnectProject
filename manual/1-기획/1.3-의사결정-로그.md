# 의사결정 로그 (Decision Log)

**작성일**: 2024-12-30
**작성자**: Development Team
**버전**: 1.0

---

## 📌 요약

프로젝트 진행 중 내린 주요 기술적/비즈니스적 의사결정을 기록하고, 선택 이유와 트레이드오프를 명확히 합니다.

---

## 템플릿

```markdown
### [결정 번호] 결정 제목
- **날짜**: YYYY-MM-DD
- **결정자**: 이름
- **상태**: 승인됨 / 보류 / 폐기

#### 문제
무엇을 해결하려 했는가?

#### 고려한 대안들
1. 대안 A
   - 장점:
   - 단점:

2. 대안 B
   - 장점:
   - 단점:

#### 최종 선택
선택한 대안과 이유

#### 리스크
예상되는 문제점 및 대응 방안

#### 관련 링크
- PR:
- 이슈:
- 코드:
```

---

## 결정 목록

### [D-001] Spring Security + JWT 인증 방식 선택
- **날짜**: 2024-10-01
- **결정자**: Backend Team
- **상태**: ✅ 승인됨

#### 문제
사용자 인증 방식을 어떻게 구현할 것인가?

#### 고려한 대안들

1. **세션 기반 인증**
   - 장점: Spring 기본 지원, 구현 간단
   - 단점: 확장성 낮음 (서버 상태 저장), 모바일 앱 대응 어려움

2. **OAuth 2.0 (소셜 로그인)**
   - 장점: 사용자 편의성, 보안 강화
   - 단점: 구현 복잡도 높음, 외부 의존성

3. **JWT 기반 인증**
   - 장점: Stateless, 확장성 좋음, 모바일 대응 용이
   - 단점: 토큰 무효화 어려움, 크기 큼

#### 최종 선택
**JWT 기반 인증**

**이유**:
- 향후 모바일 앱 개발 시 동일 API 사용 가능
- MSA 전환 시 유리 (서버 간 상태 공유 불필요)
- React SPA 구조에 적합

**구현**:
- Access Token: 1시간 유효
- Refresh Token: 미구현 (Phase 2)
- 401 에러 시 자동 로그아웃

#### 리스크
1. **토큰 탈취 시 무효화 불가**
   - 대응: 유효기간 짧게 설정 (1시간)
   - 향후: Refresh Token + Blacklist 도입

2. **토큰 크기 증가**
   - 대응: Claim 최소화 (userId, role만 포함)

#### 관련 링크
- 코드: `/src/main/java/com/tigger/closetconnectproject/Common/Jwt/`
- 문서: `/CLAUDE.md`

---

### [D-002] RabbitMQ 메시지 큐 도입
- **날짜**: 2024-11-15
- **결정자**: Backend Team
- **상태**: ✅ 승인됨

#### 문제
AI 이미지 처리는 시간이 오래 걸려 (10-60초) 동기 처리 시 사용자 대기 시간 발생.

#### 고려한 대안들

1. **동기 처리**
   - 장점: 구현 간단
   - 단점: 사용자 대기 시간 길어짐, 타임아웃 위험

2. **Thread Pool + CompletableFuture**
   - 장점: 추가 인프라 불필요
   - 단점: 서버 재시작 시 작업 유실, 확장성 낮음

3. **RabbitMQ 메시지 큐**
   - 장점: 작업 영속성, 수평 확장 가능, 재시도 지원
   - 단점: 인프라 추가, 학습 곡선

4. **Kafka**
   - 장점: 대용량 처리, 로그 저장
   - 단점: 오버엔지니어링, 운영 복잡도 높음

#### 최종 선택
**RabbitMQ**

**이유**:
- AI 처리는 Task Queue 패턴에 적합 (Kafka는 Event Stream 용도)
- 작업 영속성 보장 (서버 재시작 시에도 유실 안 됨)
- Python AI 서버와 Spring 서버 간 비동기 통신
- 재시도, Dead Letter Queue 지원

**구현**:
- Queue: `cloth.processing.queue`
- Exchange: `cloth.processing.exchange`
- WebSocket (STOMP)으로 진행도 전송

#### 리스크
1. **RabbitMQ 서버 장애 시 작업 처리 중단**
   - 대응: RabbitMQ 모니터링, 클러스터링 (Phase 2)

2. **메시지 순서 보장 안 됨**
   - 대응: 현재는 문제 없음 (각 옷은 독립적)

#### 관련 링크
- 문서: `/RABBITMQ_SETUP_GUIDE.md`
- 코드: `/src/main/java/com/tigger/closetconnectproject/Common/Config/RabbitMQConfig.java`

---

### [D-003] Google Gemini AI를 가상 Try-On에 사용
- **날짜**: 2024-12-20
- **결정자**: AI Team
- **상태**: ✅ 승인됨

#### 문제
여러 옷을 조합한 가상 착용 이미지를 어떻게 생성할 것인가?

#### 고려한 대안들

1. **기존 Virtual Try-On 모델 (VITON-HD, HR-VITON)**
   - 장점: Try-On 전용 모델
   - 단점: GPU 필수, 로컬 서버 부담, 품질 낮음

2. **Stable Diffusion Inpainting**
   - 장점: 커스터마이징 가능, 무료
   - 단점: 프롬프트 엔지니어링 어려움, GPU 필수

3. **Google Gemini Imagen 3**
   - 장점: 고품질, GPU 불필요 (API), 구현 간단
   - 단점: API 비용 발생

4. **OpenAI DALL-E 3**
   - 장점: 고품질
   - 단점: Gemini보다 비쌈

#### 최종 선택
**Google Gemini Imagen 3**

**이유**:
- API 방식으로 서버 부담 최소화
- 품질이 가장 우수
- 비용 합리적 ($0.04/image)
- 빠른 응답 속도 (5-10초)

**구현**:
- 동적 프롬프트 생성 (선택한 아이템에 따라 변경)
- 이미지 순서를 프롬프트에 명시하여 정확도 향상

#### 리스크
1. **API 비용 증가**
   - 대응:
     - 호출 수 제한 (1일 10회/사용자)
     - 캐싱 (동일 조합 재생성 방지)

2. **API 장애 시 서비스 중단**
   - 대응: Fallback 메시지 표시, 재시도 로직

#### 관련 링크
- 코드: `/aiModel/services/tryon/gemini_tryon_service.py`

---

### [D-004] OOTD 메뉴를 "내 옷장"과 "날씨 추천" 사이에 배치
- **날짜**: 2024-12-30
- **결정자**: Product Team
- **상태**: ✅ 승인됨

#### 문제
OOTD(Outfit Of The Day) 기능을 어디에 배치할 것인가?

#### 고려한 대안들

1. **내 옷장 하위 메뉴**
   - 장점: 옷장과 관련성 높음
   - 단점: 접근성 낮아질 수 있음

2. **독립 메뉴 (최상단)**
   - 장점: 강조 효과
   - 단점: 메뉴 순서 혼란

3. **독립 메뉴 (내 옷장과 날씨 추천 사이)**
   - 장점: 논리적 흐름 (옷장 → 코디 → 날씨 추천)
   - 단점: 없음

#### 최종 선택
**독립 메뉴 (내 옷장과 날씨 추천 사이)**

**이유**:
- 사용자 흐름이 자연스러움
  1. 내 옷장에서 옷 등록
  2. OOTD에서 코디 조합
  3. 날씨 추천으로 실제 착용
- OOTD는 핵심 기능이므로 독립 메뉴 필요
- 아이콘 ✨으로 시각적 강조

#### 리스크
없음

#### 관련 링크
- 코드: `/prontend/ClosetConnectProject/frontend/src/components/Sidebar.jsx`

---

### [D-005] localStorage를 통한 업로드 진행도 복구
- **날짜**: 2024-12-25
- **결정자**: Frontend Team
- **상태**: ✅ 승인됨

#### 문제
사용자가 옷 업로드 중 페이지를 새로고침하거나 나갔다가 돌아오면 진행도를 볼 수 없음.

#### 고려한 대안들

1. **상태 유지 안 함**
   - 장점: 구현 간단
   - 단점: UX 나쁨

2. **서버에 진행도 상태 저장**
   - 장점: 정확한 동기화
   - 단점: DB 부담, 구현 복잡도

3. **localStorage에 상태 저장**
   - 장점: 구현 간단, 서버 부담 없음
   - 단점: 서버 상태와 불일치 가능성

#### 최종 선택
**localStorage에 상태 저장**

**이유**:
- 빠른 구현 가능
- 대부분의 경우 정상 작동
- 서버 부담 없음

**구현**:
- ClothUploadContext에서 activeUploads를 localStorage에 저장
- 페이지 로드 시 복구

#### 리스크
1. **서버-클라이언트 상태 불일치**
   - 예: 서버는 완료했는데 localStorage는 처리 중
   - 대응: 추후 서버 상태 확인 API 추가 고려

2. **오래된 작업이 남아있을 수 있음**
   - 대응: 24시간 이상 작업은 자동 삭제 (Phase 2)

#### 관련 링크
- 코드: `/prontend/ClosetConnectProject/frontend/src/contexts/ClothUploadContext.jsx`

---

### [D-006] 동적 프롬프트 생성으로 AI Try-On 정확도 개선
- **날짜**: 2024-12-28
- **결정자**: AI Team
- **상태**: ✅ 승인됨

#### 문제
신발만 선택했을 때 AI가 이미지 순서를 잘못 인식하여 Try-On 실패.

#### 고려한 대안들

1. **고정 프롬프트 유지**
   - 장점: 구현 간단
   - 단점: 신발만 선택 시 실패

2. **동적 프롬프트 생성**
   - 장점: 선택한 아이템에 맞게 정확한 설명
   - 단점: 프롬프트 생성 로직 추가

#### 최종 선택
**동적 프롬프트 생성**

**이유**:
- 사용자가 어떤 조합을 선택하든 정확하게 작동
- 프롬프트에 이미지 순서를 명확히 명시

**구현**:
```python
def _generate_dynamic_prompt(upper, lower, shoes, accessories):
    wearing_items = []
    image_index = 1

    if upper:
        wearing_items.append(f"the upper garment from image {image_index}")
        image_index += 1
    if lower:
        wearing_items.append(f"the lower garment from image {image_index}")
        image_index += 1
    if shoes:
        wearing_items.append(f"the shoes from image {image_index}")
        image_index += 1

    return f"wearing {', '.join(wearing_items)}"
```

#### 리스크
없음

#### 관련 링크
- 코드: `/aiModel/services/tryon/gemini_tryon_service.py`

---

## 보류/폐기된 결정

### [D-XXX] Refresh Token 도입 (보류)
- **날짜**: 2024-10-15
- **결정자**: Backend Team
- **상태**: ⏸️ 보류 (Phase 2)

#### 문제
Access Token 만료 시 자동 로그아웃되어 UX가 불편함.

#### 이유
- MVP에서는 1시간 유효기간으로 충분
- Refresh Token 구현 복잡도 높음
- Phase 2에서 도입 예정

---

## 변경 이력

| 날짜 | 버전 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 2024-12-30 | 1.0 | Development Team | 초기 문서 작성, 주요 결정 6건 기록 |
