# ClosetConnect 포트폴리오 발표 PPT 구성안

> **작성 관점**: 시니어 PM + 시니어 백엔드/풀스택 엔지니어
> **발표 목적**: 면접/데모 발표용
> **슬라이드 수**: 14장

---

## 슬라이드 1: 표지

### 제목
**ClosetConnect — AI 기반 스마트 옷장 & 패션 플랫폼**

### 불릿
- 풀스택 개인 프로젝트 (기획 → 설계 → 구현 → 배포)
- React + Spring Boot + FastAPI + RabbitMQ
- 비동기 AI 이미지 처리 & 실시간 진행도 시스템
- 2024 ~ 2025

### 임팩트 문장
> "옷 한 장 업로드로, AI가 알아서 누끼 따고 분류한다"

### 발표 대본
안녕하세요. ClosetConnect 프로젝트를 발표하겠습니다. 이 프로젝트는 AI 기반 디지털 옷장 플랫폼으로, 사용자가 옷 사진을 업로드하면 AI가 자동으로 배경을 제거하고, 의류를 분류하며, 깔끔한 결과물을 제공합니다. 저는 기획부터 배포까지 전 과정을 직접 수행했으며, 특히 비동기 처리와 실시간 진행도 시스템 설계에 집중했습니다. 오늘 발표는 결과물을 먼저 보여드린 후, 제작 의도와 기술적 선택의 이유를 설명하겠습니다.

---

## 슬라이드 2: 결과물 데모 — 핵심 시나리오

### 제목
**결과물: 옷 업로드 → AI 처리 → 확정까지 30초**

### 불릿
- **STEP 1**: 사용자가 옷 사진 업로드 (Multipart, 최대 10MB)
- **STEP 2**: 실시간 진행도 표시 (0% → 25% → 50% → 70% → 95% → 100%)
- **STEP 3**: 4가지 결과 이미지 생성 (원본 / 배경제거 / 세그멘테이션 / 인페인팅)
- **STEP 4**: AI가 카테고리 자동 추천 (상의/하의/신발/액세서리)
- **STEP 5**: 사용자 확인 후 `CONFIRMED` 상태로 최종 저장
- **STEP 6**: 내 옷장에서 조회/관리 가능

### 임팩트 문장
> "업로드 한 번에 4종 이미지 + 자동 분류까지"

### 발표 대본
먼저 결과물부터 보여드리겠습니다. 사용자가 옷 사진을 업로드하면, 화면에 실시간으로 진행률이 표시됩니다. 25%에서 배경 제거, 50%에서 세그멘테이션, 70%에서 이미지 확장, 95%에서 인페인팅이 완료됩니다. 최종적으로 4가지 버전의 이미지가 생성되고, AI가 "이건 상의입니다"라고 카테고리를 추천합니다. 사용자가 확인 버튼을 누르면 CONFIRMED 상태가 되어 옷장에 저장됩니다. 전체 프로세스는 약 20~30초 내외입니다.

### 📸 필요 스크린샷
1. 업로드 화면 (파일 선택 UI)
2. 진행도 표시 화면 (프로그레스 바 + 현재 단계 텍스트)
3. 결과 화면 (4종 이미지 타일 뷰 + 추천 카테고리)
4. 확정 버튼 클릭 전/후 상태 변화

---

## 슬라이드 3: 결과물 — 처리 흐름 증거

### 제목
**기술 증거: 메시지 → WebSocket → UI 반영**

### 불릿
- `POST /api/v1/cloth/upload` → Spring이 파일 저장 + `Cloth(status=PROCESSING)` 생성
- RabbitMQ `cloth.processing.queue`로 메시지 발행 (clothId, imageBytes, userId)
- Python Worker가 단계별로 `cloth.progress.queue`에 진행도 발행 (0~100%)
- Spring `ClothProgressConsumer`가 수신 → STOMP로 `/queue/cloth/progress/{userId}` 브로드캐스트
- 프론트엔드 SockJS 클라이언트가 수신 → 프로그레스 바 업데이트
- 완료 시 `cloth.result.queue` → DB 업데이트 → `READY_FOR_REVIEW`

### 임팩트 문장
> "3개 큐, 2개 컨슈머, 1개 WebSocket으로 실시간 UX 구현"

### 발표 대본
기술적으로 어떻게 동작하는지 설명드리겠습니다. 업로드 API가 호출되면 Spring이 파일을 저장하고, Cloth 엔티티를 PROCESSING 상태로 생성합니다. 동시에 RabbitMQ의 cloth.processing 큐로 메시지를 발행합니다. Python Worker가 이 메시지를 받아 AI 파이프라인을 실행하면서, 각 단계마다 progress 큐로 진행률을 보냅니다. Spring의 Consumer가 이를 받아 STOMP WebSocket으로 프론트엔드에 전달합니다. 프론트는 SockJS로 연결되어 있어 실시간으로 프로그레스 바가 업데이트됩니다.

### 📸 필요 스크린샷/다이어그램
1. RabbitMQ 관리 콘솔 (3개 큐 목록: processing, progress, result)
2. 브라우저 개발자 도구 - WebSocket 메시지 로그
3. Spring 로그 (메시지 수신/발행 로그)
4. 시퀀스 다이어그램 (Upload → MQ → Worker → MQ → WS → Frontend)

---

## 슬라이드 4: 제작 의도 — 문제 정의

### 제목
**왜 만들었나: "옷장 관리"의 불편함**

### 불릿
- **문제 1**: 옷 사진 정리가 번거로움 — 배경 지저분, 크기 제각각
- **문제 2**: AI 이미지 처리는 수 초~수십 초 소요 — HTTP 동기 방식은 타임아웃 위험
- **문제 3**: 처리 중 "지금 어디까지 됐지?" 알 수 없음 — 사용자 이탈 유발
- **문제 4**: 잘못 처리된 결과를 바로 저장하면 데이터 오염
- **해결 방향**: 비동기 처리 + 실시간 진행도 + 사용자 확인 후 확정

### 임팩트 문장
> "동기 API의 한계를 비동기 + 이벤트 기반으로 극복"

### 발표 대본
이 프로젝트를 시작한 이유입니다. 옷장 앱을 만들려면 사용자가 올린 사진을 깔끔하게 가공해야 합니다. 그런데 AI 처리는 5초에서 30초까지 걸릴 수 있습니다. 일반적인 동기 API로 처리하면 프론트엔드 요청이 타임아웃 될 수 있고, 사용자는 "얼마나 기다려야 하지?"라는 불확실함을 느낍니다. 또한 AI가 잘못 처리한 결과를 바로 저장하면 데이터 품질이 떨어집니다. 그래서 비동기 처리, 실시간 진행도, 사용자 확인 후 확정이라는 3가지 전략을 도입했습니다.

---

## 슬라이드 5: 제작 의도 — 타겟층 & 성공 기준

### 제목
**누구를 위한 서비스인가**

### 불릿
- **주 타겟층**: TBD (추후 기입 — 예: 옷 정리가 필요한 20~30대, 패션 관심층 등)
- **보조 타겟층**: TBD (추후 기입 — 예: 중고 의류 판매자, OOTD 공유 원하는 사용자 등)
- **성공 기준 (UX)**: 업로드 후 30초 내 결과 확인 가능
- **성공 기준 (안정성)**: AI 처리 실패 시에도 서버 다운 없음 (메시지 큐 버퍼링)
- **성공 기준 (비용)**: TBD (추후 기입 — 예: AI API 호출 최적화 수치)
- **측정 방법**: TBD (추후 기입 — 예: 처리 성공률, 평균 처리 시간 등)

### 발표 대본
타겟층은 추후 구체화할 예정이지만, 기본적으로 옷 정리에 시간을 쓰기 싫은 사용자, 깔끔한 옷장 이미지를 원하는 사용자를 대상으로 합니다. 성공 기준으로는 첫째, 업로드 후 30초 내 결과를 볼 수 있어야 합니다. 둘째, AI 처리가 실패해도 전체 시스템이 멈추면 안 됩니다. RabbitMQ가 메시지를 버퍼링하므로 Worker가 죽어도 재시작 후 처리가 이어집니다. 구체적인 비용 절감 수치나 사용자 반응은 추후 측정 후 기입하겠습니다.

---

## 슬라이드 6: 컨셉 — 제품 & 기술 컨셉

### 제목
**컨셉: "업로드만 하면 끝" 자동화 옷장**

### 불릿
- **제품 컨셉**: 사진 한 장으로 디지털 옷장 완성 — 누끼, 분류, 저장까지 자동화
- **기술 컨셉**: 이벤트 기반 비동기 아키텍처 (Event-Driven Async Architecture)
- **차별점 1 (기술)**: 3-큐 RabbitMQ 구조로 처리/진행도/결과 분리
- **차별점 2 (UX)**: WebSocket 실시간 피드백으로 사용자 이탈 방지
- **차별점 3 (데이터)**: `READY_FOR_REVIEW` 상태로 사용자 확인 후 확정
- **핵심 가치**: 긴 처리 시간을 "기다림"이 아닌 "진행 상황 공유"로 전환

### 임팩트 문장
> "비동기 + 실시간 = 사용자가 기다리지 않는 경험"

### 발표 대본
제품 컨셉은 단순합니다. 사진 한 장 업로드하면 나머지는 AI가 알아서 합니다. 기술적으로는 이벤트 기반 비동기 아키텍처를 채택했습니다. 핵심 차별점은 세 가지입니다. 첫째, RabbitMQ를 3개 큐로 분리해서 처리 요청, 진행도, 결과를 독립적으로 관리합니다. 둘째, WebSocket으로 실시간 피드백을 주어 사용자가 "지금 어디까지 됐지?"를 항상 알 수 있습니다. 셋째, 처리 완료 후 바로 저장하지 않고 사용자 확인을 거쳐 데이터 품질을 보장합니다.

---

## 슬라이드 7: 시스템 아키텍처

### 제목
**아키텍처: Multi-Cloud + Message-Driven**

### 불릿
- **Frontend**: React 18 + Vite → Vercel (글로벌 CDN)
- **Backend**: Spring Boot 3.5.7 + MariaDB + RabbitMQ → Railway
- **AI Services**: FastAPI/Flask + PyTorch/Transformers → Google Cloud Run (자동 스케일링)
- **통신 패턴**:
  - 동기: REST API (JWT 인증)
  - 비동기: RabbitMQ (Direct Exchange)
  - 실시간: STOMP WebSocket + SockJS Fallback
- **외부 API**: Toss Payments, Google Gemini/Imagen, Weather API

### 📊 필요 다이어그램
```
[React/Vercel] ←→ [Spring Boot/Railway] ←→ [MariaDB]
                         ↓↑
                   [RabbitMQ/Railway]
                         ↓↑
              [FastAPI Workers/Cloud Run]
                         ↓
           [Gemini API] [Imagen API] [SegFormer]
```

### 발표 대본
전체 아키텍처입니다. 프론트엔드는 React로 개발해 Vercel에 배포했습니다. 백엔드는 Spring Boot로 Railway에 배포했고, 같은 Railway에서 MariaDB와 RabbitMQ도 운영합니다. AI 서비스는 FastAPI로 개발해 Google Cloud Run에 배포했습니다. Cloud Run은 요청이 없으면 인스턴스를 0으로 줄이고, 요청이 오면 자동으로 스케일업합니다. 통신은 3가지 패턴을 사용합니다. REST API, RabbitMQ 메시지, WebSocket 실시간 통신입니다.

### 📸 필요 스크린샷
1. Railway 대시보드 (Spring + MariaDB + RabbitMQ)
2. Google Cloud Run 서비스 목록
3. Vercel 배포 화면

---

## 슬라이드 8: 도메인 상태 전이

### 제목
**Cloth 상태 머신: 5단계 라이프사이클**

### 불릿
```
UPLOADING → PROCESSING → READY_FOR_REVIEW → COMPLETED
                ↓                              ↓
              FAILED ←──────────────────────(재처리)
```
- `UPLOADING`: 파일 수신 중
- `PROCESSING`: AI 파이프라인 실행 중 (배경제거 → 세그멘테이션 → 확장 → 인페인팅)
- `READY_FOR_REVIEW`: 처리 완료, 사용자 확인 대기
- `COMPLETED`: 사용자 확정 완료, 옷장에 저장
- `FAILED`: 처리 실패 (재시도 또는 수동 처리 필요)

### 임팩트 문장
> "5단계 상태로 데이터 품질과 추적성 확보"

### 발표 대본
Cloth 엔티티의 상태 전이입니다. 처음 업로드가 시작되면 UPLOADING, 파일이 저장되고 MQ로 전송되면 PROCESSING이 됩니다. AI 처리가 끝나면 READY_FOR_REVIEW가 되어 사용자에게 결과를 보여줍니다. 사용자가 확인 버튼을 누르면 COMPLETED가 되어 최종 저장됩니다. 만약 AI 처리 중 오류가 나면 FAILED가 됩니다. 이 상태 머신 덕분에 "지금 이 옷이 어떤 단계에 있는지" 명확히 추적할 수 있고, 실패한 건만 따로 재처리할 수 있습니다.

### 📊 필요 다이어그램
1. 상태 전이 다이어그램 (State Machine Diagram)
2. Cloth 엔티티 ERD (주요 컬럼 포함)

---

## 슬라이드 9: 마켓플레이스 & 결제 흐름

### 제목
**마켓: 중고 거래 + Toss Payments 연동**

### 불릿
- **상품 상태**: `ON_SALE` → `RESERVED` → `SOLD`
- **주문 상태**: `PAYMENT_PENDING` → `PAYMENT_PAID` → `SHIPPED` → `CONFIRMED` → `SETTLEMENT_RELEASED`
- **결제 흐름**: Toss Payments API 연동 (confirm → 결제 승인)
- **취소/환불**: `CANCELLED` / `REFUNDED` 상태 지원
- **추가 기능**: 구매자-판매자 채팅 (WebSocket), 상품 좋아요, 댓글

### 발표 대본
옷장에 저장된 옷을 중고 거래로 판매할 수 있습니다. 상품 상태는 ON_SALE에서 시작해 예약되면 RESERVED, 거래 완료되면 SOLD가 됩니다. 주문은 Toss Payments와 연동했습니다. 결제 대기, 결제 완료, 배송, 구매 확정, 정산 완료까지 6단계로 관리됩니다. 취소나 환불도 별도 상태로 추적합니다. 추가로 구매자와 판매자가 실시간 채팅할 수 있도록 WebSocket 기반 채팅 기능도 구현했습니다.

### 📸 필요 스크린샷
1. 상품 등록 화면
2. 결제 화면 (Toss Payments 위젯)
3. 주문 내역 화면 (상태 뱃지 표시)
4. 채팅 화면

---

## 슬라이드 10: AI 파이프라인 상세

### 제목
**AI 처리: 4단계 파이프라인**

### 불릿
| 단계 | 기술 | 진행률 | 결과물 |
|------|------|--------|--------|
| 1. 배경 제거 | rembg + U2Net | 25% | removedBgImageUrl |
| 2. 세그멘테이션 | SegFormer (Hugging Face) | 50% | segmentedImageUrl + 카테고리 |
| 3. 이미지 확장 | Google Imagen | 70% | 크롭 영역 복원 |
| 4. 인페인팅 | Stable Diffusion | 95% | inpaintedImageUrl |

- **세그멘테이션 모델**: `mattmdjaga/segformer_b2_clothes` (18개 클래스)
- **카테고리 매핑**: 상의(TOP) / 하의(BOTTOM) / 신발(SHOES) / 액세서리(ACC)

### 발표 대본
AI 파이프라인은 4단계로 구성됩니다. 첫째, rembg 라이브러리와 U2Net 모델로 배경을 제거합니다. 둘째, SegFormer 모델로 의류 영역을 정밀하게 세그멘테이션하고, 18개 클래스 중 어떤 의류인지 분류합니다. 셋째, Google Imagen API로 크롭되어 잘린 부분을 자연스럽게 확장합니다. 넷째, Stable Diffusion 기반 인페인팅으로 최종 이미지를 완성합니다. 각 단계마다 progress 큐로 진행률을 발행해서 프론트엔드에 실시간 표시됩니다.

### 📸 필요 스크린샷
1. 원본 이미지 → 배경 제거 결과 비교
2. 세그멘테이션 결과 (마스크 오버레이)
3. 인페인팅 전/후 비교
4. 최종 4종 이미지 타일

---

## 슬라이드 11: 운영 관점 — 안정성 & 에러 핸들링

### 제목
**운영: 장애 대응 & 모니터링**

### 불릿
- **메시지 내구성**: RabbitMQ Durable Queue — Worker 재시작해도 메시지 유지
- **처리 실패 시**: `FAILED` 상태로 마킹, 재처리 가능 구조
- **타임아웃 방지**: AI 처리를 MQ로 분리해 HTTP 타임아웃 회피
- **상태 추적**: DB에 `processingStatus` + `progressPercentage` 저장
- **모니터링**: TBD (추후 기입 — 예: Prometheus, Grafana, CloudWatch 등)
- **알림**: TBD (추후 기입 — 예: Slack 알림, 이메일 등)

### 발표 대본
운영 관점에서 안정성을 고려한 설계입니다. RabbitMQ 큐는 Durable 옵션으로 설정해서 브로커가 재시작되어도 메시지가 유실되지 않습니다. AI Worker가 처리 중 죽어도 메시지는 큐에 남아있어 Worker가 다시 떠오르면 이어서 처리합니다. 처리가 실패하면 FAILED 상태로 마킹되어, 관리자가 원인 파악 후 재처리할 수 있습니다. AI 처리를 동기 API가 아닌 MQ로 분리했기 때문에 HTTP 타임아웃 문제가 발생하지 않습니다. 모니터링과 알림 시스템은 추후 구축 예정입니다.

---

## 슬라이드 12: 결과물 리뷰 — 잘된 점 & 한계

### 제목
**회고: 잘된 점과 개선 필요점**

### 불릿
**✅ 잘된 점**
- 비동기 + 실시간 조합으로 긴 처리 시간에도 좋은 UX 제공
- 3-큐 분리 구조로 역할 명확화 (요청/진행/결과)
- 상태 머신으로 데이터 일관성 확보
- Multi-cloud 배포로 각 서비스 특성에 맞는 인프라 선택

**⚠️ 한계/개선 필요**
- AI 처리 비용 최적화 필요 (현재 매 요청마다 전체 파이프라인 실행)
- 재처리 자동화 미구현 (수동 재시도 필요)
- 배치 업로드 미지원 (현재 1장씩만 처리)
- 테스트 커버리지 확대 필요

### 발표 대본
잘된 점과 한계를 솔직하게 말씀드리겠습니다. 잘된 점은 비동기와 실시간을 조합해서 AI 처리라는 긴 작업에도 사용자가 답답하지 않게 만든 것입니다. 큐를 3개로 분리해서 각각의 역할이 명확하고, 상태 머신으로 데이터 라이프사이클을 관리합니다. 한계도 있습니다. 현재는 매 요청마다 전체 AI 파이프라인이 실행되어 비용이 많이 듭니다. 실패 시 자동 재처리가 없어 수동으로 해야 하고, 여러 장을 한 번에 업로드하는 기능도 아직 없습니다.

---

## 슬라이드 13: 트레이드오프 & 로드맵

### 제목
**트레이드오프와 다음 단계**

### 불릿
**⚖️ 트레이드오프**
| 선택 | 얻은 것 | 잃은 것 |
|------|---------|---------|
| RabbitMQ | 비동기 처리, 버퍼링 | 인프라 복잡성 증가 |
| WebSocket | 실시간 UX | 연결 관리 부담 |
| 사용자 확인 단계 | 데이터 품질 | 추가 클릭 필요 |
| Multi-cloud | 유연성, 비용 최적화 | 운영 복잡성 |

**🚀 로드맵 (다음 개선)**
1. 배치 업로드 (여러 장 동시 처리)
2. AI 비용 최적화 (세그멘테이션 결과 캐싱, 선택적 파이프라인)
3. 실패 자동 재처리 (DLQ + Retry 정책)
4. 가상 피팅 고도화 (Gemini Vision 활용)

### 발표 대본
모든 기술 선택에는 트레이드오프가 있었습니다. RabbitMQ를 도입해 비동기 처리와 버퍼링을 얻었지만, 인프라가 복잡해졌습니다. WebSocket으로 실시간 UX를 제공하지만 연결 관리가 추가됩니다. 사용자 확인 단계로 데이터 품질을 높였지만 클릭이 하나 더 필요합니다. 다음 단계로는 배치 업로드, AI 비용 최적화, 자동 재처리, 가상 피팅 고도화를 계획하고 있습니다.

---

## 슬라이드 14: 예상 질문 & 마무리

### 제목
**예상 질문 Q&A**

### 불릿
**Q1. 왜 RabbitMQ를 선택했나요? Kafka는?**
> A: 이 프로젝트는 고처리량보다 "메시지별 확실한 처리"가 중요합니다. RabbitMQ의 Direct Exchange와 ACK 기반 전달 보장이 적합했습니다. Kafka는 대용량 스트리밍에 강하지만, 이 규모에서는 오버스펙입니다.

**Q2. WebSocket 연결이 끊기면 어떻게 되나요?**
> A: SockJS Fallback이 있어 WebSocket이 안 되면 Long Polling으로 전환됩니다. 또한 DB에 `progressPercentage`를 저장해두므로, 재접속 시 `GET /api/v1/cloth/{id}/status`로 현재 상태를 조회할 수 있습니다.

**Q3. AI 처리가 실패하면?**
> A: Cloth 상태가 `FAILED`로 마킹됩니다. 현재는 수동 재처리가 필요하며, 향후 Dead Letter Queue와 자동 재시도 정책을 도입할 예정입니다.

**Q4. 비용은 어떻게 관리하나요?**
> A: TBD (추후 기입 — 예: Cloud Run 0 스케일링, API 호출 최적화 사례 등)

**Q5. 테스트는 어떻게 하셨나요?**
> A: 현재 139개의 단위 테스트가 작성되어 있습니다. 통합 테스트와 E2E 테스트는 확대할 예정입니다.

### 발표 대본
마지막으로 예상 질문에 대한 답변입니다. RabbitMQ를 선택한 이유는 메시지별 확실한 전달이 중요했기 때문입니다. 고처리량 스트리밍이 목적이 아니라 "이 옷 처리 요청이 반드시 Worker에게 도달"하는 게 중요합니다. WebSocket이 끊겨도 DB에 상태가 저장되어 있어 API로 조회할 수 있습니다. AI 처리 실패 시에는 FAILED 상태로 마킹하고, 향후 자동 재시도를 구현할 예정입니다.

---

## 마무리 슬라이드

### 한 문장 요약 (30자 내)
> **"비동기 AI 처리 + 실시간 진행도 = 스마트 옷장"**

### 차별점 3개 (각 1줄)
1. **3-큐 RabbitMQ 아키텍처**로 처리/진행/결과 분리하여 역할 명확화
2. **WebSocket 실시간 피드백**으로 긴 AI 처리도 사용자가 기다리지 않는 UX
3. **5단계 상태 머신**으로 데이터 라이프사이클 추적 및 품질 보장

---

# 📸 필요 스크린샷/다이어그램 총정리

## 화면 스크린샷
| 번호 | 화면 | 용도 |
|------|------|------|
| 1 | 옷 업로드 화면 (파일 선택 UI) | 슬라이드 2 |
| 2 | 진행도 표시 화면 (프로그레스 바) | 슬라이드 2 |
| 3 | 결과 화면 (4종 이미지 + 추천 카테고리) | 슬라이드 2, 10 |
| 4 | 확정 전/후 상태 변화 | 슬라이드 2 |
| 5 | 상품 등록 화면 | 슬라이드 9 |
| 6 | Toss 결제 화면 | 슬라이드 9 |
| 7 | 주문 내역 (상태 뱃지) | 슬라이드 9 |
| 8 | 채팅 화면 | 슬라이드 9 |
| 9 | 원본 → 배경제거 비교 | 슬라이드 10 |
| 10 | 세그멘테이션 결과 | 슬라이드 10 |
| 11 | 인페인팅 전/후 | 슬라이드 10 |

## 인프라 스크린샷
| 번호 | 화면 | 용도 |
|------|------|------|
| 12 | RabbitMQ 관리 콘솔 (3개 큐) | 슬라이드 3 |
| 13 | 브라우저 DevTools WebSocket 로그 | 슬라이드 3 |
| 14 | Spring 로그 (메시지 발행/수신) | 슬라이드 3 |
| 15 | Railway 대시보드 | 슬라이드 7 |
| 16 | Cloud Run 서비스 목록 | 슬라이드 7 |
| 17 | Vercel 배포 화면 | 슬라이드 7 |

## 다이어그램 (직접 제작 필요)
| 번호 | 다이어그램 | 용도 |
|------|-----------|------|
| D1 | 시스템 아키텍처 (React-Spring-MQ-AI) | 슬라이드 7 |
| D2 | 메시지 시퀀스 다이어그램 | 슬라이드 3 |
| D3 | Cloth 상태 전이 다이어그램 | 슬라이드 8 |
| D4 | Order 상태 전이 다이어그램 | 슬라이드 9 |
| D5 | AI 파이프라인 플로우 | 슬라이드 10 |

---

# 발표 시간 예상

| 슬라이드 | 예상 시간 |
|----------|----------|
| 1. 표지 | 30초 |
| 2. 결과물 데모 | 1분 30초 |
| 3. 기술 증거 | 1분 |
| 4. 문제 정의 | 1분 |
| 5. 타겟층 | 45초 |
| 6. 컨셉 | 1분|
| 7. 아키텍처 | 1분 30초 |
| 8. 상태 전이 | 1분 |
| 9. 마켓플레이스 | 1분 |
| 10. AI 파이프라인 | 1분 |
| 11. 운영 | 45초 |
| 12. 회고 | 1분|
| 13. 트레이드오프 | 1분|
| 14. Q&A | 1분 30초 |
| **총합** | **약 15분** |

---

*이 문서는 ClosetConnect 프로젝트의 포트폴리오 발표용 PPT 스크립트입니다.*
*작성일: 2025년 1월*
